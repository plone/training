# SOME DESCRIPTIVE TITLE.
# Copyright (C) The text and illustrations in this website are licensed by
# the Plone Foundation under a Creative Commons Attribution 4.0
# International license.
# This file is distributed under the same license as the Mastering Plone
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Mastering Plone 1.2.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-04-20 15:07-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.4.0\n"

#: ../relations.rst:2
msgid "Relations"
msgstr ""

#: ../relations.rst:4
msgid ""
"Relations are a difficult topic. To master relations you must understand "
"the stack of packages involved."
msgstr ""

#: ../relations.rst:7
msgid ""
"Relations are based on `zc.relation`. This package allows to store "
"transitive and intransitive n-ary relationships. It allows for complex "
"relationships and searches along them. Because of this functionality, the"
" package is a bit complicated."
msgstr ""

#: ../relations.rst:12
msgid ""
"The package `zc.relation` provides its own catalog, a relation catalog. "
"This is a storage optimized for the queries needed. `zc.relation` is sort"
" of an outlier with regards to zope documentation. It has extensive "
"documentation, with a good level of doctests for explaining things."
msgstr ""

#: ../relations.rst:17
msgid ""
"You can use `zc.relation` to store the objects and its relations directly"
" into the catalog. But the additional packages that make up the relation "
"functionality don't use the catalog this way."
msgstr ""

#: ../relations.rst:20
msgid ""
"We want to work with schemas to get auto generated forms. The logic for "
"this is provided by the package `z3c.relationfield`. This package "
"contains the RelationValue object and everything needed to define a "
"relation schema, and all the code that is necessary to automatically "
"update the catalog."
msgstr ""

#: ../relations.rst:25
msgid ""
"A RelationValue Object does not reference all objects directly. For the "
"target, it uses an id it gets from the `IntId` Utility. This id allows "
"direct recovery of the obect. The source object stores it directly."
msgstr ""

#: ../relations.rst:29
msgid ""
"Widgets are provided by `plone.app.z3cform`. Some converters are provided"
" by `plone.app.relationfield`. The widget that Plone uses can also store "
"objects directly. Because of this, the following happens when saving a "
"relation via a form:"
msgstr ""

#: ../relations.rst:33
msgid "The html shows some nice representation of selectable objects."
msgstr ""

#: ../relations.rst:34
msgid ""
"When the user submits the form, selected items are submitted by their "
"UUIDs."
msgstr ""

#: ../relations.rst:35
msgid "The Widget retrieves the original object with the UUID."
msgstr ""

#: ../relations.rst:36
msgid "Some Datamanager gets another unique ID from an IntID Tool."
msgstr ""

#: ../relations.rst:37
msgid ""
"The same datamanager creates a RelationValue from this id, and stores "
"this relation value on the source object."
msgstr ""

#: ../relations.rst:38
msgid "Some Event handlers update the catalogs."
msgstr ""

#: ../relations.rst:40
msgid "It is surprisingly easy to to use RelationFields."
msgstr ""

#: ../relations.rst:42
msgid "I show you how to do it TTW..."
msgstr ""

#: ../relations.rst:44
msgid ""
"If you want to modify Relations, you have to create or delete "
"RelationValue objects. If you want to find out what objects are related "
"to each other, you use the relation catalog. Here is an example:"
msgstr ""

#: ../relations.rst:50
msgid ""
"RelationValue objects have a fairly complete API. For both target and "
"source, you can receive the IntId, the object and the path. On a "
"RelationValue, the terms `source` and `target` aren't used. Instead, they"
" are `from` and `to`. So the API for getting the target is:"
msgstr ""

#: ../relations.rst:56
msgid "`to_id`"
msgstr ""

#: ../relations.rst:57
msgid "`to_path`"
msgstr ""

#: ../relations.rst:58
msgid "`to_object`"
msgstr ""

#: ../relations.rst:60
msgid ""
"In addition, the relation value knows under which attribute it has been "
"stored. You could delete a Relation like this `delattr(rel.from_object, "
"rel.from_attribute)`"
msgstr ""

#: ../relations.rst:64
msgid ""
"This is a terrible idea by the way, because when you define in your "
"schema that one can store multiple RelationValues, your Relation is "
"stored in a list on this attribute."
msgstr ""

#: ../relations.rst:68
msgid ""
"Relations depend on a lot of infrastructure to work. This infrastructure "
"in turn depends a lot on event handlers being thrown properly. When this "
"is not the case things can break. Because of this, there is a method "
"`isBroken` which you can use to check if the target is available."
msgstr ""

#: ../relations.rst:74
msgid ""
"There are alternatives to using Relations. You could instead just store "
"the UUID of an object. But Using real relations and the catalog allows "
"for very powerful things. The simplest concrete advantage is the "
"possibility to see what links to your object."
msgstr ""

